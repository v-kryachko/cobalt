# Copyright 2016 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

################################################################################
# DEFAULT BUILD CONFIGURATION
################################################################################

import("compiler.gni")
import("platform.gni")
import("sysroot.gni")

if (mini_chromium_is_mac) {
  declare_args() {
    # The minimum runtime macOS version that built products are expected to run
    # on. If empty, the toolchain will choose its own default, typically the
    # older of the SDK version and the build host’s OS version.
    mac_deployment_target = "10.9"
  }
} else if (mini_chromium_is_ios) {
  import("ios/ios_sdk.gni")
} else if (mini_chromium_is_linux) {
  declare_args() {
    # Path to the Clang toolchain. If unset, uses the system-installed Clang.
    clang_path = ""

    # If set, link against libstdc++ statically.
    link_libstdcpp_statically = false
  }
} else if (mini_chromium_is_fuchsia) {
  declare_args() {
    # Path to the Fuchsia Clang toolchain.
    clang_path = "//third_party/fuchsia/clang/" + host_os + "-amd64"
  }
} else if (mini_chromium_is_win) {
  declare_args() {
    # Path to the Windows toolchain. If "<autodetect>", discovery of the
    # system-installed toolchain will be attempted. Otherwise,
    # win_sdk\bin\SetEnv.cmd inside this path will be used to configure the
    # Windows toolchain.
    win_toolchain_path = "<autodetect>"
  }
}

declare_args() {
  # Extra flags passed to the C compiler.
  # Space-separated string of flags.
  # "cflags" are passed to all invocations of the C, C++, Objective-C, and
  # Objective-C++ compilers.
  extra_cflags = ""

  # Extra flags passed to the C compiler.
  # Space-separated string of flags.
  extra_cflags_c = ""

  # Extra flags passed to the C++ compiler.
  # Space-separated string of flags.
  extra_cflags_cc = ""

  # Extra flags passed to the Objective-C compiler.
  # Space-separated string of flags.
  extra_cflags_objc = ""

  # Extra flags passed to the Objective-C++ compiler.
  # Space-separated string of flags.
  extra_cflags_objcc = ""

  # Extra flags passed to the linker.
  # Space-separated string of flags.
  # These flags are passed on the command-line to the linker and generally
  # specify various linking options.
  extra_ldflags = ""

  # Extra arguments passed to static_library archiver
  # Space-separated string of flags.
  # A list of flags passed to the archive/lib command that creates static
  # libraries.
  extra_arflags = ""
}

config("debug") {
  if (!mini_chromium_is_win) {
    cflags = [ "-g" ]
  }
}

config("release") {
  defines = [ "NDEBUG" ]

  if (mini_chromium_is_posix || mini_chromium_is_fuchsia) {
    cflags = [ "-O3" ]
    if (mini_chromium_is_mac || mini_chromium_is_ios) {
      ldflags = [ "-Wl,-dead_strip" ]
    } else {
      cflags += [
        "-fdata-sections",
        "-ffunction-sections",
      ]
      ldflags = [
        "-Wl,-O1",
        "-Wl,--gc-sections",
      ]
    }
  } else if (mini_chromium_is_win) {
    cflags = [
      "/GL",  # LTCG.
      "/O2",
      "/Ob2",  # Both explicit and auto inlining.
      "/Oy-",  # Disable omitting frame pointers, must be after /O2.
      "/Zc:inline",  # Remove unreferenced COMDAT (faster links).
      "/d2Zi+",  # Improve debugging of optimized code.
    ]
    ldflags = [
      "/OPT:ICF",
      "/OPT:REF",
      "/LTCG",
    ]
    arflags = [ "/LTCG" ]
  }
}

config("default") {
  common_flags = []

  asmflags = []
  ldflags = []
  if (mini_chromium_is_posix || mini_chromium_is_fuchsia) {
    cflags = [
      "-Wall",
      "-Wendif-labels",
      "-Werror",
      "-Wextra",
      "-Wextra-semi",
      "-Wno-missing-field-initializers",
      "-Wno-unused-parameter",
      "-Wsign-compare",
      "-fno-exceptions",
      "-fno-rtti",
      "-fno-strict-aliasing",  # See https://crbug.com/32204
      "-fobjc-call-cxx-cdtors",
      "-fstack-protector-all",  # Implies -fstack-protector
      "-fvisibility-inlines-hidden",
      "-fvisibility=hidden",
    ]

    cflags_c = [ "-std=c11" ]
    cflags_cc = [ "-std=c++14" ]
    cflags_objc = cflags_c
    cflags_objcc = cflags_cc

    cflags += [
      "-Wheader-hygiene",
      "-Wnewline-eof",
      "-Wstring-conversion",
    ]

    if (sysroot != "") {
      if (sysroot == rebase_path(sysroot)) {
        # If it’s already system-absolute, leave it alone.
        sysroot_path = sysroot
      } else {
        sysroot_path = rebase_path(sysroot, root_build_dir)
      }
      if (mini_chromium_is_mac || mini_chromium_is_ios) {
        common_flags += [
          "-isysroot",
          sysroot_path,
        ]
      } else {
        common_flags += [ "--sysroot=" + sysroot_path ]
      }
    }

    if (mini_chromium_is_mac || mini_chromium_is_ios) {
      if (current_cpu == "x86") {
        common_flags += [
          "-arch",
          "i386",
        ]
      } else if (current_cpu == "x64") {
        common_flags += [
          "-arch",
          "x86_64",
        ]
      } else if (current_cpu == "arm64") {
        common_flags += [
          "-arch",
          "arm64",
        ]
      }
    }

    if (mini_chromium_is_fuchsia) {
      common_flags += [
        # The Fuchsia SDK no longer dumps everything in the sysroot, preferring
        # the layout described in
        # https://fuchsia.googlesource.com/docs/+/master/development/sdk/layout.md.
        # Eventually /sysroot will be replaced by /pkg/system, but this work is
        # not yet complete.
        "-isystem",
        rebase_path(fuchsia_sdk + "/pkg/fdio/include", root_build_dir),
      ]

      lib_dirs = [ fuchsia_sdk + "/arch/$target_cpu/lib" ]
    }
  }

  if (mini_chromium_is_mac) {
    if (mac_deployment_target != "") {
      common_flags += [ "-mmacosx-version-min=" + mac_deployment_target ]
    }
  }

  if (mini_chromium_is_ios) {
    if (ios_deployment_target != "") {
      if (current_cpu == "x64") {
        common_flags +=
            [ "-mios-simulator-version-min=" + ios_deployment_target ]
      } else if (current_cpu == "arm64") {
        common_flags += [ "-mios-version-min=" + ios_deployment_target ]
      }
    }
  }

  if (mini_chromium_is_win) {
    cflags = [
      "/DNOMINMAX",
      "/DUNICODE",
      "/DWIN32_LEAN_AND_MEAN",
      "/D_CRT_SECURE_NO_WARNINGS",
      "/D_HAS_EXCEPTIONS=0",
      "/D_UNICODE",
      "/FS",
      "/W4",
      "/WX",
      "/Zi",
      "/bigobj",  # Support larger number of sections in obj file.
      "/wd4100",  # Unreferenced formal parameter.
      "/wd4127",  # Conditional expression is constant.
      "/wd4324",  # Structure was padded due to alignment specifier.
      "/wd4351",  # New behavior: elements of array will be default initialized.
      "/wd4577",  # 'noexcept' used with no exception handling mode specified.
      "/wd4996",  # 'X' was declared deprecated.
    ]

    ldflags += [ "/DEBUG" ]

    libs = [ "kernel32.lib" ]
  }

  if (mini_chromium_is_linux) {
    defines = [ "_FILE_OFFSET_BITS=64" ]
    common_flags += [ "-pthread" ]

    # This is currently required by the clang toolchain build that DEPS uses
    # from the Fuchsia team. Only a static libc++ is provided, and it requires
    # both -ldl and -pthread. (-pthread was already needed by mini_chromium and
    # Crashpad). Eventually, the clang build should automatically add these
    # when needed, but it does not do that yet, so manually add libdl here for
    # now.
    libs = [ "dl" ]

    if (link_libstdcpp_statically) {
      # The sysroot being built against is based on Stretch, which is newer than
      # the libstdc++ that's on Trusty (14.04) which is the Chromium minspec.
      # This minspec determines what the available buildbots are. Chromium
      # doesn't have a problem with libstdc++ despite this, because it links
      # against a local copy of libc++ instead. As this build file only affects
      # the standalone Crashpad build, when this flag is set link libstdc++
      # statically to avoid the problem on the bots.
      cflags += [ "-stdlib=libstdc++" ]
      ldflags += [
        "-rtlib=libgcc",
        "-static-libstdc++",
        "-stdlib=libstdc++",
      ]
    }
  }

  if (mini_chromium_is_fuchsia) {
    if (target_cpu == "arm64") {
      common_flags += [ "--target=aarch64-fuchsia" ]
    } else if (target_cpu == "x64") {
      common_flags += [ "--target=x86_64-fuchsia" ]
    } else {
      assert(false, "Unsupported architecture")
    }

    # fdio is listed in ldflags instead of libs because it’s important for it to
    # be loaded in Fuchsia processes that expect POSIX-like file descriptor
    # semantics, even if they don’t explicitly reference anything in the fdio
    # library. To avoid inadvertently losing the runtime dependency, it must
    # come before -Wl,--as-needed below. fdio needs zircon (and zircon needs to
    # be in every process anyway).
    ldflags += [
      "-lfdio",
      "-lzircon",
    ]
  }

  if ((mini_chromium_is_posix && !mini_chromium_is_mac &&
       !mini_chromium_is_ios) || mini_chromium_is_fuchsia) {
    cflags += [ "-fPIC" ]
    ldflags += [
      # This must follow Fuchsia’s fdio library above.
      "-Wl,--as-needed",

      "-Wl,-z,noexecstack",
    ]
  }

  cflags += common_flags
  asmflags += common_flags
  ldflags += common_flags

  if (is_debug) {
    configs = [ ":debug" ]
  } else {
    configs = [ ":release" ]
  }
}

config("executable") {
  if (mini_chromium_is_linux) {
    ldflags = [ "-pie" ]
  }
}

config("ios_enable_arc") {
  if (mini_chromium_is_ios) {
    common_flags = [ "-fobjc-arc" ]
    cflags_objc = common_flags
    cflags_objcc = common_flags
  }
}

config("Wexit_time_destructors") {
  if (mini_chromium_is_clang) {
    cflags = [ "-Wexit-time-destructors" ]
  }
}

config("Wimplicit_fallthrough") {
  if (mini_chromium_is_clang) {
    cflags = [ "-Wimplicit-fallthrough" ]
  }
}

config("win_console") {
  if (mini_chromium_is_win) {
    ldflags = [ "/SUBSYSTEM:CONSOLE" ]
  }
}

config("win_windowed") {
  if (mini_chromium_is_win) {
    ldflags = [ "/SUBSYSTEM:WINDOWS" ]
  }
}
